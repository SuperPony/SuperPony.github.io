<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>坑爹的 this | SuperPony&#39;s Blog</title>
<meta name="description" content="Just for fun" />
<link rel="shortcut icon" href="https://superpony.github.io//favicon.ico?v=1575379447554">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css"
  integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://superpony.github.io//styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>


  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://superpony.github.io/">
  <img class="avatar" src="https://superpony.github.io//images/avatar.png?v=1575379447554" alt="">
  </a>
  <h1 class="site-title">
    SuperPony&#39;s Blog
  </h1>
  <p class="site-description">
    Just for fun
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/SuperPony" target="_blank">
          <i class="fab fa-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              坑爹的 this
            </h2>
            <div class="post-info">
              <span>
                2019-12-01
              </span>
              <span>
                6 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="前言">前言</h1>
<p>在 JS 中，this 真的是一个非常重要，非常重要，非常重要（重要的事情说三遍）的关键知识点，重要到如果不能理解它，绝大部分的开发都无法完成。<br>
而且， this 的适用范围也十分广泛，例如构造函数。但是， <strong>this 总是返回一个对象</strong>，又或者说，<strong>this 就是属性或方法当前所在的对象</strong>。</p>
<h2 id="基础示例">基础示例</h2>
<pre><code>    var demo = {
      name: 'tony',
      age: 25,
      say() {
        console.log(
          'my name is ' + this.name + ' i am' + this.age + ' years old.'
        )
      },

      echoObj() {
        console.log(this)
      }
    }
    demo.say()

    demo.echoObj()
    // age: 25
    // echoObj: ƒ echoObj()
    // name: &quot;tony&quot;
    // say: ƒ say()
    // __proto__: Object
</code></pre>
<h1 id="this-的使用场景">this 的使用场景</h1>
<ul>
<li>全局环境下 使用 this， this 的指向是 window 对象。</li>
<li>构造函数中使用 this ， this 的指向是 实例对象。</li>
<li>对象的方法中使用 this，this 的指向就是方法运行时所在的对象，这一点也是最难把握的。</li>
</ul>
<h2 id="对象方法中使用-this">对象方法中使用 this</h2>
<pre><code>    var a = {
      name: 'tony',
      sayMyName() {
        console.log('my name is ' + this.name)
      }
    }

    var b = {
      name: 'mike'
    }

    var c = {
      name: 'miya'
    }

    // this 返回的总是当前方法运行时，所在的对象。
    b.say = a.sayMyName
    b.say() // my name is mike
    c.say = a.sayMyName
    c.say() // my name is miya
</code></pre>
<h1 id="this-指向的是本层级的对象">this 指向的是本层级的对象</h1>
<pre><code>     var d = {
      name: 'tom',
      e: {
        say() {
          console.log(this.name)
        }
      }
    }
    d.e.say() 
    //输出 undefined， this 代表的是本层级的对象，这里的 this 指向的 e 对象， e 对象是没有 name 属性的 
</code></pre>
<h1 id="this-使用注意点">this 使用注意点</h1>
<h2 id="避免多级嵌套使用-this">避免多级嵌套使用 this</h2>
<p>由于 this 的指向是很灵活的，所以最好尽可能的少在代码中，尤其是函数中使用多层的 this。</p>
<pre><code>    var a = {
      echoThis() {
        console.log(this)
        var b = (function() {
          console.log(this)
        })()
      }
    }

    a.echoThis() // b 的 this 指向的是 window。
    // 实际执行的代码如下
    var echoThis = (function() {
      console.log(this)
    })()

    var b = {
      echoThis() {
        console.log(this)
      }
    }
</code></pre>
<h2 id="避免在数组处理方法中使用-this">避免在数组处理方法中使用 this</h2>
<p>在数组的处理方法中，例如 map 或 forEach ，允许提供一个函数参数，此时这个函数，就不因该使用 this，因为它会指向 window。</p>
<pre><code>    let arr = [1, 2, 3]
    arr.map(function() {
      console.log(this)
    })
    // 输出 三个 window 对象。
</code></pre>
<h2 id="避免在回调函数中使用-this">避免在回调函数中使用 this</h2>
<p>在回调函数中，经常会改变 this 的指向，因此最好慎重甚至避免使用。</p>
<pre><code>     let a = new Object({
      b() {
        console.log(this)
      }
    })

    a.f = (function() {
      console.log(this) // 对象 window
    })()

    a.c = function() {
      console.log(this)
    }

    le button = document.getElementById('demo')
    button.addEventListener('click', a.c) // button 节点

    a.b() // 对象 a
</code></pre>
<h1 id="this-的绑定">this 的绑定</h1>
<p>由于动态的 this 切换，虽然为 JS 创造了巨大的灵活性，但是也使得编程变得很模糊和困难，因此 this 绑定和切换油然而生。<br>
this 的绑定/切换有5种解决方法，三个 JS 提供的函数。一个将 this 赋予变量的解决方案，以及使用 ES6 的“箭头”语法来定义函数。</p>
<h2 id="this-赋予变量">this 赋予变量</h2>
<pre><code>    let a = {
        f() {
            b = (function() {
            console.log(this)
            })() // 此时的 this 指向 window

            let that = this // 将当前 this 赋予一个变量
            b2 = (function() {
            console.log(that) // 通过使用 that 来代替 this
            })()
        }
    }
    a.f()
</code></pre>
<h2 id="call-方法">call 方法</h2>
<p><code>function.prototype.call(obj，params...)</code> call方法可以为方法绑定方法内 this 指向的对象，并直接调用该方法。当 obj 为 nudefined、null 或空参数时则为 <code>window</code> 对象，当 obj 传入的是一个值时，则 JS 会自动转为对应的包装对象。<br>
call 方法可以传入多个参数，后面的参数是原本要传入函数的参数。</p>
<pre><code>let f = function(params) {
    console.log(this)
}

let b = {
    name: 'b'
}

let c = {
    name: 'c'
}

b.f = f
b.f() // b 对象

c.f = f
// call(obj) 方法可以为方法中的 this 绑定指定的对象。因此，下面输出 b
c.f.call(b) // b 对象
// call 方法如果不传参数，则默认传入 window 对象。
c.f.call() // window 对象

c.f.call(666) // Number 对象
</code></pre>
<h2 id="apply-方法">apply 方法</h2>
<p><code>function.prototype.apply(obj, [params...])</code> , apply 与 call 相似，唯一区别在于，传入函数需要的参数时， apply 是以数组形式传入。</p>
<pre><code>let a = {
    say(paramA, paramB) {
    console.log(paramA, paramB)
    }
}

a.say.apply(null, ['tony', 'mike']) // tony , mike
</code></pre>
<h2 id="bind-方法">bind 方法</h2>
<p>apply 和 call 方法虽然已经可以将 this 的绑定按照我们的心意来改变，可这两个方法依然有一个小缺点；就是，在为函数绑定 this 的同时，也会触发该函数，可有时我们并不希望在绑定的时候，就触发，因此，就可以通过 <code>function.prototype.bind(obj)</code>  来为函数绑定对象， bind() 方法会返回一个新的函数，该函数就是已经进行过 this 绑定的函数。</p>
<pre><code>   let a = {
      name: 'a',
      f() {
        console.log(this)
      }
    }

    let b = {
      name: 'b'
    }

    b.f = a.f
    b.f() // b 对象
    let demo = b.f.bind(a) // 返回一个新的函数
    demo() // a 对象
</code></pre>
<h2 id="箭头函数">箭头函数</h2>
<p>箭头函数是 ES6 才引进的一种“新的” 语法，可以用来定义函数，箭头函数与普通函数相比，箭头函数内部的 this 指向是<strong>代码定义时所在的对象</strong>，而不是<strong>代码运行时所在的对象</strong>。因此，箭头函数特别适合作为回调函数的内部使用。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E5%89%8D%E8%A8%80">前言</a>
<ul>
<li><a href="#%E5%9F%BA%E7%A1%80%E7%A4%BA%E4%BE%8B">基础示例</a></li>
</ul>
</li>
<li><a href="#this-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">this 的使用场景</a>
<ul>
<li><a href="#%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BD%BF%E7%94%A8-this">对象方法中使用 this</a></li>
</ul>
</li>
<li><a href="#this-%E6%8C%87%E5%90%91%E7%9A%84%E6%98%AF%E6%9C%AC%E5%B1%82%E7%BA%A7%E7%9A%84%E5%AF%B9%E8%B1%A1">this 指向的是本层级的对象</a></li>
<li><a href="#this-%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9">this 使用注意点</a>
<ul>
<li><a href="#%E9%81%BF%E5%85%8D%E5%A4%9A%E7%BA%A7%E5%B5%8C%E5%A5%97%E4%BD%BF%E7%94%A8-this">避免多级嵌套使用 this</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E5%9C%A8%E6%95%B0%E7%BB%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BD%BF%E7%94%A8-this">避免在数组处理方法中使用 this</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E5%9C%A8%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8-this">避免在回调函数中使用 this</a></li>
</ul>
</li>
<li><a href="#this-%E7%9A%84%E7%BB%91%E5%AE%9A">this 的绑定</a>
<ul>
<li><a href="#this-%E8%B5%8B%E4%BA%88%E5%8F%98%E9%87%8F">this 赋予变量</a></li>
<li><a href="#call-%E6%96%B9%E6%B3%95">call 方法</a></li>
<li><a href="#apply-%E6%96%B9%E6%B3%95">apply 方法</a></li>
<li><a href="#bind-%E6%96%B9%E6%B3%95">bind 方法</a></li>
<li><a href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0">箭头函数</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://superpony.github.io//post/tcp-ip-xie-yi-xue-xi">
              <h3 class="post-title">
                TCP / IP 协议 流程
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '188a6590013429e9c097',
    clientSecret: 'e923744b63525d11d81f31da6e79a5f1c005f68b',
    repo: 'SuperPony.github.io',
    owner: 'SuperPony',
    admin: ['SuperPony'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  nice to meet you ～  | 
  <a class="rss" href="https://superpony.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()

  let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

  // This should probably be throttled.
  // Especially because it triggers during smooth scrolling.
  // https://lodash.com/docs/4.17.10#throttle
  // You could do like...
  // window.addEventListener("scroll", () => {
  //    _.throttle(doThatStuff, 100);
  // });
  // Only not doing it here to keep this Pen dependency-free.

  window.addEventListener("scroll", event => {
    let fromTop = window.scrollY;

    mainNavLinks.forEach((link, index) => {
      let section = document.getElementById(decodeURI(link.hash).substring(1));
      let nextSection = null
      if (mainNavLinks[index + 1]) {
        nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
      }
      if (section.offsetTop <= fromTop) {
        if (nextSection) {
          if (nextSection.offsetTop > fromTop) {
            link.classList.add("current");
          } else {
            link.classList.remove("current");    
          }
        } else {
          link.classList.add("current");
        }
      } else {
        link.classList.remove("current");
      }
    });
  });

</script>

      </div>
    </div>
  </body>
</html>
