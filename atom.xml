<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://superpony.github.io/</id>
    <title>SuperPony&apos;s Blog</title>
    <updated>2019-11-07T11:25:32.361Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://superpony.github.io/"/>
    <link rel="self" href="https://superpony.github.io//atom.xml"/>
    <subtitle>Just for fun</subtitle>
    <logo>https://superpony.github.io//images/avatar.png</logo>
    <icon>https://superpony.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, SuperPony&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[关于技术方面的学习方法和路线]]></title>
        <id>https://superpony.github.io//post/guan-yu-ji-zhu-fang-mian-de-xue-xi-fang-fa-he-lu-xian</id>
        <link href="https://superpony.github.io//post/guan-yu-ji-zhu-fang-mian-de-xue-xi-fang-fa-he-lu-xian">
        </link>
        <updated>2019-11-07T10:20:13.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>写这篇文章的原因是，最近这两天在学习 极客时间 上面程劭非老师的 <strong><a href="https://time.geekbang.org/column/intro/100023201">重学前端</a></strong> 课程，在读完第一章的 明确前端学习路线与方法 后，觉着写的很好，在尝试去理解之后，觉着不仅可以用于在前端的学习之上，在学习其他的编程语言上，也完全适用，于是就想着写点东西，一篇参杂着我个人理解的笔记。</p>
<p>在刚学习 至 1年内相关工作经验的时候，因该把侧重点放在基础知识上，地基打得牢，楼才建的高。这一年也是最关键的一年，因为这一年的学习，正是构架自己 <strong>知识架构</strong> 的黄金时期。</p>
<h1 id="学习的两种方法">学习的两种方法</h1>
<p>1.构建自己的知识架构。<br>
2.追本溯源。</p>
<h1 id="什么是知识架构">什么是知识架构</h1>
<p>知识架构可以理解为你自己 知识的目录或索引，它可以把我们的知识，或是那些零散的<strong>知识组织串联起来</strong>，同时也可以帮助我们发现自己的知识盲区，不足之处。<br>
注意：知识架构是有优劣之分的，而区分优劣最重要的评判标准就是，你的知识架构，它的<strong>逻辑性和完备性如何</strong>。</p>
<h2 id="举例">举例</h2>
<p>如果我们尝试做了一个自己的知识架构，是如下这个样子的，那就是不好的。</p>
<ul>
<li>类型转换；</li>
<li>this 指针；</li>
<li>闭包；</li>
<li>作用域链；</li>
<li>......<br>
为什么不好？因为这种知识架构，知识之间没有任何的逻辑性可言，知识之间，既不是循序渐进的递进关系，也不是平级关系，更不具备完备性。</li>
</ul>
<h1 id="如何做知识架构">如何做知识架构</h1>
<p>以 JS 搭建最顶层为例：</p>
<ul>
<li>文法</li>
<li>语义</li>
<li>运行时<br>
之所这么分，是因为，对于任何计算机语言而言，必然是“用规定的文法，去表达特定的语义，最终操作运行时”的一个过程。<br>
这么以来，不管你学习的是什么 JS 的知识，都不会越出这个范围，这就是知识架构的完备性。</li>
</ul>
<p>接下来继续往下分：</p>
<ul>
<li>文法</li>
<li>词法</li>
<li>语法</li>
<li>语义</li>
<li>运行时</li>
<li>类型</li>
<li>执行过程<br>
文法可以向下分为 词法和语法，这是来自编译的划分，同样是具有完备性的。语义跟语法具有一一对应的关系。<br>
对于运行时的部分，有一句很有名的话叫做： **程序 = 算法 + 数据结构 **，那么对于运行时来说，类型就是数据结构，执行过程就是算法。<br>
而如果继续往下分，词法之中就包含了 直接量，关键字，运算符等等，语法和语义则就包含了 表达式，语句，函数，对象，模块 等。</li>
</ul>
<h1 id="个人理解">个人理解</h1>
<p>我个人认为，不一定要完全按照上面这份分类方法，因为每个人对于一门知识的“内力“深浅是不同的，就注定了理解是不同的，而如果一味的邯郸学步，只会是害自己。所以，我个人认为，对于构建自己的知识架构上，我们要学的，就是一句话 <strong>一定要确保自己的知识架构是具有逻辑性和完备性的</strong>，或者说，自己的知识架构，一定要是由浅入深，循序渐进的；且最顶层的结构，一定要是最大的范围，任何 JS 知识点，都跳不出这个范围。</p>
<h1 id="追本溯源">追本溯源</h1>
<p>有一些知识，它的背后是有一个很大的体系的，例如 CSS 中， width 和 display 。 这两个属性都是知识，但其背后的知识量，完全是不可比肩的。 width 属性看到单词就可以知道是什么意思什么作用，它只是一个单纯的数值。而 display 就不一样了，如果想彻底搞清楚 display 就必须去学习和理解正常流，弹性布局等等知识。<br>
又或者一些知识，涉及的概念本身经历了各种历史变迁，变得非常复杂和具有争议性，例如 MVC，从 1979 年至今，概念变化是非常大的。<br>
像这种时候，就需要做一些考古工作了，而追本溯源就是通过 关注 技术提出的背景，关注原始的论文或文章，或是关注作者说的话。通过这种方式，可以帮助我们去理解一些看上去不合理的东西和问题。</p>
<h1 id="个人理解-2">个人理解</h1>
<p>当我们遇到一些看起来“很怪”，“很不合理” 的东西时，也许可以通过追溯历史背景，追溯源头的方式，来理解这个东西。而当我们遇到一些背后知识量很大或是很生涩难以理解的知识时，可以通过去学习其底层的方法，来学习它。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS 中的权重/优先级]]></title>
        <id>https://superpony.github.io//post/css-zhong-de-quan-chong-you-xian-ji</id>
        <link href="https://superpony.github.io//post/css-zhong-de-quan-chong-you-xian-ji">
        </link>
        <updated>2019-11-06T08:52:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="这是啥">这是啥？</h1>
<p>CSS 中的权重决定了假如一个元素被赋予了多个 CSS 样式，且多个样式中，有相同的属性，那么它最终渲染的结果使用的是那一个样式中的属性，也就是说， CSS的权重，决定了元素最终的样式。</p>
<p>举个例子：</p>
<pre><code>&lt;template&gt;
    &lt;div class=&quot;demo&quot; id=&quot;demo&quot; style=&quot;color:red;&quot;&gt; hello world &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {

    }
&lt;/script&gt;

&lt;style scoped&gt;
    .demo {
        color: blue;
    }

    #demo {
        font-size: 50px;
        color: green;
    }
&lt;/style&gt;
</code></pre>
<p>上面的代码，最终这个 div 内的文字最终渲染结果是什么？🤔<br>
答案是，红色的字，字体大小50px。<br>
为什么会是这个结果，因为这就是 CSS 权重比较之后的结果，字体颜色是红色的，是因为行内式的权值是最高的，而字体大小是 50px 是因为，在所有选择器中，只有一个 关于字体大小的定义，所以它直接生效。</p>
<h1 id="css-权值">CSS 权值</h1>
<p>每一个CSS的选择器都有一个相对的重要程度值，也就是权重的值，简称权值。当多个选择器作用于一个元素上且多个选择器内有相同的属性时，那个选择器的权值大，相同的属性最终就用谁的。</p>
<h2 id="权值等级">权值等级</h2>
<ul>
<li>第一等级：行内样式， 例如 <code>&lt;input style=&quot;&quot; /&gt;</code> ,权值为 1，0，0，0</li>
<li>第二等级：ID 选择器，权值 0，1，0，0</li>
<li>第三等级：class，伪类，属性选择器，权值0，0，1，0</li>
<li>第四等级：元素选择器，伪元素选择器，权值 0，0，0，1</li>
<li>第五等级：通配符选择器，子选择器，相邻兄弟 等选择器 权值 0，0，0，0</li>
</ul>
<h2 id="权值计算公式">权值计算公式</h2>
<p>权值 = 第一等级选择器*个数,第二等级选择器*个数,第三等级选择器*个数,第四等级选择器*个数；</p>
<h1 id="优先级总结">优先级总结</h1>
<ul>
<li>先进行高等级比较，如果相同，再比较下一等级，以此类推。</li>
<li>如果权值完全相同的话，采用 后者优先的原则（样式覆盖）。</li>
<li>CSS 属性后如果追加 !important  时，无条件绝对优先。</li>
</ul>
<h1 id="注意">注意</h1>
<p>网上有一些关于权值计算的文章中，会出现把权值的计算理解为 权值 = 第一等级选择器 * 个数 + 第二等级选择器 * 个数 + 第三等级选择器 * 个数 + 第四等级选择器*个数； 也就是说把权值的计算理解为了 等级*各自个数再求和。举个例子：</p>
<pre><code>&lt;template&gt;
    &lt;div id=&quot;demo&quot; class=&quot;a b c d e f g h i j k&quot;&gt; i'm a man &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {

    }
&lt;/script&gt;

&lt;style scoped&gt;
    .a,
    .b,
    .c,
    .d,
    .e,
    .f,
    .g,
    .h,
    .i,
    .j,
    .k {
        font-size: 50px;
        color: blue;
    }

    #demo {
        color: red;
    }
&lt;/style&gt;
</code></pre>
<p>上面的代码，如果按照 等级*各自选择器个数再求和 的公式来计算，第一个选择器的权值为：1000*0+100*0+10*11+1*0 = 110。  第二个选择器权值为 1000*0+100*1+10*0+1*0 = 100。 则最终 实际渲染结果为 蓝色的字，50px大小。<br>
但最终结果却是， 红色的字 50px 大小。因为，低等级的选择器，无论个数再多，也是无法越等级的。则实际计算结果因该是 第一个选择器权值： 0，0，11，0 。 第二个选择器权值 0，1，0，0 。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS 规范标准]]></title>
        <id>https://superpony.github.io//post/css-gui-fan-biao-zhun</id>
        <link href="https://superpony.github.io//post/css-gui-fan-biao-zhun">
        </link>
        <updated>2019-11-06T08:27:27.000Z</updated>
        <content type="html"><![CDATA[<h1 id="代码风格">代码风格</h1>
<ul>
<li>采用 UTF-8 编码， 在 CSS 头部引用 @charset &quot;utf-8&quot;。</li>
<li>以 4 个空格作为缩进。</li>
<li>每行不超过 120 字符，除非单行不可分割。</li>
<li>选择器嵌套层级不大于 3 级。</li>
<li>尽量不要使用 @import，因为 与 <links> 相比， @import 速度更慢，增加了额外的页面请求，并可能导致无法预料的问题。</li>
<li>Media Query不得单独编排，必须与相关的规则一起定义。</li>
</ul>
<h1 id="样式属性排序">样式属性排序</h1>
<h2 id="布局位置">布局位置</h2>
<p>display &gt; position &gt; top &gt; right &gt; bottom &gt; left &gt; z-index &gt; float &gt; clear &gt; vertical-align &gt; list-style &gt; content</p>
<h2 id="自身属性">自身属性</h2>
<p>width &gt; height &gt; padding &gt; border &gt; margin  &gt; background</p>
<h2 id="文本属">文本属</h2>
<p>font &gt; font-size &gt; font-weight &gt; font-family &gt; text-align &gt; text-decoration &gt; text-indent &gt; line-height</p>
<p>white-space &gt; text-ellipsis</p>
<h2 id="其他属性">其他属性</h2>
<p>color &gt; background &gt; cursor &gt; zoom</p>
<h2 id="css3属性">css3属性</h2>
<p>box-sizing &gt; box-shadow &gt; border-radius &gt; transform &gt; transition</p>
<h1 id="书写规范">书写规范</h1>
<ul>
<li>优先使用可以缩写的属性。</li>
<li>取消小数点前的 0。</li>
</ul>
<pre><code>font-size: 0.5em; /*bad*/ 
font-size: .5em; /*good*/ 
</code></pre>
<h1 id="命名规范">命名规范</h1>
<p>头：header</p>
<p>内容：content/container</p>
<p>尾：footer</p>
<p>导航：nav</p>
<p>侧栏：sidebar</p>
<p>栏目：column</p>
<p>页面外围控制整体佈局宽度：wrapper</p>
<p>左右中：left right center</p>
<p>登录条：loginbar</p>
<p>标志：logo</p>
<p>广告：banner</p>
<p>页面主体：main</p>
<p>热点：hot</p>
<p>新闻：news</p>
<p>下载：download</p>
<p>子导航：subnav</p>
<p>菜单：menu</p>
<p>子菜单：submenu</p>
<p>搜索：search</p>
<p>友情链接：friendlink</p>
<p>页脚：footer</p>
<p>版权：copyright</p>
<p>滚动：scroll</p>
<p>内容：content</p>
<p>标签：tags</p>
<p>文章列表：list</p>
<p>提示信息：msg</p>
<p>小技巧：tips</p>
<p>栏目标题：title</p>
<p>加入：joinus</p>
<p>指南：guide</p>
<p>服务：service</p>
<p>注册：regsiter</p>
<p>状态：status</p>
<p>投票：vote</p>
<p>合作伙伴：partner</p>
<p>ID的命名-页面结构</p>
<p>容器: container</p>
<p>页头：header</p>
<p>内容：content/container</p>
<p>页面主体：main</p>
<p>页尾：footer</p>
<p>导航：nav</p>
<p>侧栏：sidebar</p>
<p>栏目：column</p>
<p>页面外围控制整体佈局宽度：wrapper</p>
<p>左右中：left right center</p>
<p>ID的命名-导航</p>
<p>导航：nav</p>
<p>主导航：mainnav</p>
<p>子导航：subnav</p>
<p>顶导航：topnav</p>
<p>边导航：sidebar</p>
<p>左导航：leftsidebar</p>
<p>右导航：rightsidebar</p>
<p>菜单：menu</p>
<p>子菜单：submenu</p>
<p>标题: title</p>
<p>摘要: summary</p>
<p>ID的命名-功能</p>
<p>标志：logo</p>
<p>广告：banner</p>
<p>登陆：login</p>
<p>登录条：loginbar</p>
<p>注册：register</p>
<p>搜索：search</p>
<p>功能区：shop</p>
<p>标题：title</p>
<p>加入：joinus</p>
<p>状态：status</p>
<p>按钮：btn</p>
<p>滚动：scroll</p>
<p>标签页：tab</p>
<p>文章列表：list</p>
<p>提示信息：msg</p>
<p>当前的: current</p>
<p>小技巧：tips</p>
<p>图标: icon</p>
<p>注释：note</p>
<p>指南：guild</p>
<p>服务：service</p>
<p>热点：hot</p>
<p>新闻：news</p>
<p>下载：download</p>
<p>投票：vote</p>
<p>合作伙伴：partner</p>
<p>友情链接：link</p>
<p>版权：copyright</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BEM]]></title>
        <id>https://superpony.github.io//post/bem</id>
        <link href="https://superpony.github.io//post/bem">
        </link>
        <updated>2019-11-06T07:08:07.000Z</updated>
        <content type="html"><![CDATA[<h1 id="什么是-bem">什么是 BEM</h1>
<ul>
<li>BEM 是俄罗斯团队 Yandex 团队提出的一种 CSS 命名方法，通过组件化/模块化的命名思想，让 CSS 的结构和命名语义更佳规范和透明，便于维护。</li>
</ul>
<h1 id="bem-的构成">BEM 的构成</h1>
<ul>
<li>BEM 由 块（block）、元素（element）、修饰符（modifier） 三个部分构成。</li>
<li>命名约定的规范如下：</li>
</ul>
<pre><code>    /* 块 */
    .my-block {}

    /* 元素 */
    .my-block__my-element {}

    /* 修饰符 */
    .my-block--my-modifier {}
    .my-block__my-element--my-modifier {}
</code></pre>
<ul>
<li>单词之间以 - 分割。</li>
</ul>
<h2 id="块">块</h2>
<ul>
<li>任何可以独立，复用而不依赖其他块的部分，都可以单独作为一个块。</li>
<li>块可以嵌套其他块，来实现业务逻辑。</li>
<li>例如 一个 from 表单，一个 header 头 都可以作为一个块，来为其单独命名。</li>
</ul>
<h2 id="元素">元素</h2>
<ul>
<li>元素是块的组成部分，对应块中的子元素/子节点。</li>
<li>元素的命名必须声名其所属的块名称。例如 <code>.my-from__input</code></li>
<li>块名与元素之间以 __  （双下划）线分割。</li>
</ul>
<h2 id="修饰符">修饰符</h2>
<ul>
<li>修饰符的意义在于让 块/元素拥有更丰富的外观或行为，来应对不同的情景。</li>
<li>修饰符不可以单独使用，它的意义是为了丰富 块/元素。</li>
<li>例如 buttom 按钮， 可以 为其定义 error 和 success 修饰符，分别为其定义属性，让其应对不同的情景。</li>
</ul>
<h2 id="示例">示例</h2>
<pre><code>&lt;template&gt;
    &lt;form class=&quot;my-form&quot;&gt;
        &lt;input class=&quot;my-form__input&quot; type=&quot;text&quot; /&gt;
        &lt;button class=&quot;my-form__button&quot;&gt;click me&lt;/button&gt;
        &lt;button class=&quot;my-form__button--danger&quot;&gt;don't click me&lt;/button&gt;
    &lt;/form&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {

    }
&lt;/script&gt;

&lt;style lang=&quot;css&quot; scoped&gt;
    /* from 可以单独作为一个可以复用的组件，所以可以将其设置为一个单独的块 */
    .my-form {
        width: 500px;
        height: 500px;
    }

    .my-form__input {
        width: 100px;
    }

    .my-form__button {
        background-color: aqua;
    }

     /* 修饰符让 块/元素 拥有更丰富的语意和情景 */
    .my-form__button--danger {
        background-color: red;
    }

    .my-form__button--danger {
        background-color: red;
    }
&lt;/style&gt; 
</code></pre>
<h1 id="bem-的好处">BEM 的好处</h1>
<ul>
<li>通过 组件化/模块化 的思想，让整个项目的 CSS 拆分，从而解耦合。</li>
<li>规范化的命名方式 <code>block__element--modifier</code> ,让整个 CSS 书写起来结构化更佳清晰，可读，灵活。</li>
<li>命名方法扁平化，可以避免样式层级过多而导致解析效率变低。</li>
</ul>
<h1 id="bem-的坏处">BEM 的坏处</h1>
<ul>
<li>命名过长。</li>
</ul>
<h1 id="总结">总结</h1>
<ul>
<li>利远大于弊。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[思考 Vue 中 computed 和 watch 的区别]]></title>
        <id>https://superpony.github.io//post/si-kao-vue-zhong-computed-he-watch-de-qu-bie</id>
        <link href="https://superpony.github.io//post/si-kao-vue-zhong-computed-he-watch-de-qu-bie">
        </link>
        <updated>2019-11-06T00:23:50.000Z</updated>
        <content type="html"><![CDATA[<p>由于本人比较笨，理解能力也不太好，所以在学习和使用 Vue 里的 computed 和 watch 的时候，遇到了一个问题，就是 这俩玩意有啥区别？于是乎，查文档带百度吧！😤</p>
<p>百度之后发现了一篇讲的个人觉着很生动和形象的 <a href="https://blog.csdn.net/mystric594/article/details/77849361">文章</a>。 当然，本着要（字）把（数）知（太）识（少）转（实）为（在）自（糊）己（弄）的（不）理（过）解（去）和（的）语（心）言（情）的（🌝）原则，还是将自己看过后的理解，写出来吧！</p>
<h1 id="computed">computed</h1>
<p>computed 适用于：一个属性的变化 依赖一个或多个属性的变化；打个比喻，它就像个没有主见的人，别人一动或者一变化，它就跟着变动。</p>
<h1 id="watch">watch</h1>
<p>watch 适用于：当一个属性变化时，自动的去改变其他的属性,或是触发一些业务逻辑，（当然这个取决于具体的业务逻辑）；它就像个很强势的人，当它变了，就会要求其他人也变动。</p>
<h1 id="ps">PS.</h1>
<ul>
<li>同时触发了 watch 和 computed 时，计算属性先触发。</li>
<li>如果假以时日，有哪位大佬看到这边文章了，请指出不足之处，万分感激！🙏</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记一次 margin 塌陷的坑]]></title>
        <id>https://superpony.github.io//post/ji-yi-ci-margin-top-de-keng</id>
        <link href="https://superpony.github.io//post/ji-yi-ci-margin-top-de-keng">
        </link>
        <updated>2019-11-04T02:48:56.000Z</updated>
        <content type="html"><![CDATA[<h1 id="起因">起因</h1>
<p>由于本人 CSS 十分的菜，所以闲暇之余，便借机会重新温习下 CSS 的知识，在练习着写一些页面样式的时候，需要用到 margin-top 属性，然后问题发生了。</p>
<p>测试代码如下：</p>
<pre><code> &lt;style&gt;
      .app {
          height: 500px;
          width: 500px;
          background-color: blue;
      }

      #demo {
          height: 100px;
          width: 100px;
          background-color: green;
          margin-top:10%;
      }

      #demo2 {
          height: 100px;
          width: 100px;
          background-color: red;
      }
  &lt;/style&gt;
   &lt;div class=&quot;app&quot;&gt;
      &lt;div id=&quot;demo&quot;&gt;&lt;/div&gt;
      &lt;div id=&quot;demo2&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
</code></pre>
<p>实际效果：<br>
<img src="https://superpony.github.io//post-images/1572837073689.png" alt=""></p>
<p>什么鬼？？？讲道理不因该是绿色的往下偏移吗？（心里一万只草泥马呼啸而过），但本着东西做不出来，一定是技师水平不到位的原则，百度一下吧！🙄</p>
<p>百度一下后，发现了一个名叫 margin 塌陷的经典问题。</p>
<h2 id="margin-塌陷">margin 塌陷</h2>
<ul>
<li>指 嵌套级的父子块级元素，<strong>首个</strong>块级子元素与父元素的 marigin-top 属性是结合在一起的，并取其最大的值。(why???),当给该子元素设置 margin-top 时，会连带着父级元素一下往下移动。</li>
</ul>
<h2 id="解决方案">解决方案</h2>
<p>需要先了解一个重要概念， <strong>BFC</strong>。</p>
<h2 id="bfc块级格式化上下文">BFC（块级格式化上下文）</h2>
<p>BFC 决定了块级元素如何对它的内容进行布局，以及与其他元素的关系和相互关系。BFC会让盒模型的渲染规则发生改变，并且创建一个新的环境与外界相隔。（将该盒模型作为一个独立的容器，容器里的子元素不会影响到外部元素）。<br>
BFC 能解决 marigin 塌陷问题的原因就在这里，它可以改变一个块级元素内的渲染规则并与外界隔离，这样内部的块级子元素就不会收到外部的影响，就好像是在父级元素顶部加了一个“框”。</p>
<h3 id="形成-bfc-的条件">形成 BFC 的条件</h3>
<ul>
<li>元素浮动， float 除了 none 以外的值。</li>
<li>元素绝对定位， absolute ｜ fixed。</li>
<li>display 为 inline-block,table-cell,table-caption。</li>
<li>overflow 除了 visible 以外的值。</li>
</ul>
<h2 id="解决方案这次是真的">解决方案（这次是真的）</h2>
<ul>
<li>通过为父元素添加 border 属性： 这种解决方案并不合适，因为添加边框会改变 div 的布局，因此不太理想。</li>
<li>通过触发父元素的 bfc 来改变父级元素的渲染规则，但在实际使用中，都会造成不同的麻烦，所以只能在实际开发过程中，根据需要来选择。</li>
<li>通过将首个块级子元素改变其显示模式，来规避 margin 塌陷。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[定位]]></title>
        <id>https://superpony.github.io//post/xiang-dui-ding-wei</id>
        <link href="https://superpony.github.io//post/xiang-dui-ding-wei">
        </link>
        <updated>2019-11-02T13:16:31.000Z</updated>
        <content type="html"><![CDATA[<h2 id="定义的三种机制">定义的三种机制</h2>
<ul>
<li>
<p>普通流 static： 元素的默认属性，没有定位，遵循文档流。</p>
</li>
<li>
<p>绝对定位 absolute：被绝对定位的元素，会彻底脱离文档流，其原本在流中占据的位置被移除。</p>
</li>
<li>
<p>相对定位：相对定位的元素以原本所在的位置进行偏移，其原本在流中的位置被保留。</p>
</li>
</ul>
<hr>
<h2 id="绝对定位">绝对定位</h2>
<h3 id="absolute">absolute</h3>
<ul>
<li>如果父元素也是使用定位的元素，则在定位时，以父元素作为参照物，否则以根元素作为参照物。</li>
<li>当以根元素作为参照物时，bottom 定位时，则是以<strong>视口</strong>的左下角进行定位，但与 fiexd 不同的是，absolute 定位的元素不会随着屏幕的滚动而移动。</li>
</ul>
<h3 id="fiexd">fiexd</h3>
<ul>
<li>fiexd 以参照物为<strong>视口</strong>，当屏幕滚动时，fiexd 定位的元素随之移动。</li>
</ul>
<hr>
<h2 id="单位">单位</h2>
<ul>
<li>
<p>百分比： 当偏移的值以 % 作为单位时，其实际移动的偏移量为 父元素宽｜高 * 百分比。</p>
</li>
<li>
<p>例如：</p>
</li>
</ul>
<pre><code>    &lt;style&gt;
        #app {
            height: 500px;
            width: 500px;
            background-color: blue;
        }

        #demo {
            height: 100px;
            width: 100px;
            background-color: green;
            position: relative;
            left: 10%; // 实际向右偏移50px。
        }
    &lt;style&gt;

    &lt;div id=&quot;app&quot;&gt;
        &lt;div id=&quot;demo&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;

</code></pre>
]]></content>
    </entry>
</feed>