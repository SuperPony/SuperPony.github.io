<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://superpony.github.io/</id>
    <title>SuperPony&apos;s Blog</title>
    <updated>2019-11-06T00:27:58.975Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://superpony.github.io/"/>
    <link rel="self" href="https://superpony.github.io//atom.xml"/>
    <subtitle>Just for fun</subtitle>
    <logo>https://superpony.github.io//images/avatar.png</logo>
    <icon>https://superpony.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, SuperPony&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[思考 Vue 中 computed 和 watch 的区别]]></title>
        <id>https://superpony.github.io//post/si-kao-vue-zhong-computed-he-watch-de-qu-bie</id>
        <link href="https://superpony.github.io//post/si-kao-vue-zhong-computed-he-watch-de-qu-bie">
        </link>
        <updated>2019-11-06T00:23:50.000Z</updated>
        <content type="html"><![CDATA[<p>  由于本人比较笨，理解能力也不太好，所以在学习和使用 Vue 里的 computed 和 watch 的时候，遇到了一个问题，就是 这俩玩意有啥区别？于是乎，查文档带百度吧！😤</p>
<p>  百度之后发现了一篇讲的个人觉着很生动和形象的 <a href="https://blog.csdn.net/mystric594/article/details/77849361">文章</a>。 当然，本着要（字）把（数）知（太）识（少）转（实）为（在）自（糊）己（弄）的（不）理（过）解（去）和（的）语（心）言（情）的（🌝）原则，还是将自己看过后的理解，写出来吧！</p>
<h1 id="computed">computed</h1>
<p>computed 适用于：一个属性的变化 依赖一个或多个属性的变化；打个比喻，它就像个没有主见的人，别人一动或者一变化，它就跟着变动。</p>
<h1 id="watch">watch</h1>
<p>watch 适用于：当一个属性变化时，去改变其他的属性,或是触发一些业务逻辑，（当然这个取决于具体的业务逻辑）；它就像个很强势的人，当它变了，就会要求其他人也变动。</p>
<h1 id="ps">PS.</h1>
<ul>
<li>同时触发了 watch 和 computed 时，计算属性先触发。</li>
<li>如果假以时日，有哪位大佬看到这边文章了，请指出不足之处，万分感激！🙏</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记一次 margin 塌陷的坑]]></title>
        <id>https://superpony.github.io//post/ji-yi-ci-margin-top-de-keng</id>
        <link href="https://superpony.github.io//post/ji-yi-ci-margin-top-de-keng">
        </link>
        <updated>2019-11-04T02:48:56.000Z</updated>
        <content type="html"><![CDATA[<h1 id="起因">起因</h1>
<p>由于本人 CSS 十分的菜，所以闲暇之余，便借机会重新温习下 CSS 的知识，在练习着写一些页面样式的时候，需要用到 margin-top 属性，然后问题发生了。</p>
<p>测试代码如下：</p>
<pre><code> &lt;style&gt;
      .app {
          height: 500px;
          width: 500px;
          background-color: blue;
      }

      #demo {
          height: 100px;
          width: 100px;
          background-color: green;
          margin-top:10%;
      }

      #demo2 {
          height: 100px;
          width: 100px;
          background-color: red;
      }
  &lt;/style&gt;
   &lt;div class=&quot;app&quot;&gt;
      &lt;div id=&quot;demo&quot;&gt;&lt;/div&gt;
      &lt;div id=&quot;demo2&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
</code></pre>
<p>实际效果：<br>
<img src="https://superpony.github.io//post-images/1572837073689.png" alt=""></p>
<p>什么鬼？？？讲道理不因该是绿色的往下偏移吗？（心里一万只草泥马呼啸而过），但本着东西做不出来，一定是技师水平不到位的原则，百度一下吧！🙄</p>
<p>百度一下后，发现了一个名叫 margin 塌陷的经典问题。</p>
<h2 id="margin-塌陷">margin 塌陷</h2>
<ul>
<li>指 嵌套级的父子块级元素，<strong>首个</strong>块级子元素与父元素的 marigin-top 属性是结合在一起的，并取其最大的值。(why???),当给该子元素设置 margin-top 时，会连带着父级元素一下往下移动。</li>
</ul>
<h2 id="解决方案">解决方案</h2>
<p>需要先了解一个重要概念， <strong>BFC</strong>。</p>
<h2 id="bfc块级格式化上下文">BFC（块级格式化上下文）</h2>
<p>BFC 决定了块级元素如何对它的内容进行布局，以及与其他元素的关系和相互关系。BFC会让盒模型的渲染规则发生改变，并且创建一个新的环境与外界相隔。（将该盒模型作为一个独立的容器，容器里的子元素不会影响到外部元素）。<br>
BFC 能解决 marigin 塌陷问题的原因就在这里，它可以改变一个块级元素内的渲染规则并与外界隔离，这样内部的块级子元素就不会收到外部的影响，就好像是在父级元素顶部加了一个“框”。</p>
<h3 id="形成-bfc-的条件">形成 BFC 的条件</h3>
<ul>
<li>元素浮动， float 除了 none 以外的值。</li>
<li>元素绝对定位， absolute ｜ fixed。</li>
<li>display 为 inline-block,table-cell,table-caption。</li>
<li>overflow 除了 visible 以外的值。</li>
</ul>
<h2 id="解决方案这次是真的">解决方案（这次是真的）</h2>
<ul>
<li>通过为父元素添加 border 属性： 这种解决方案并不合适，因为添加边框会改变 div 的布局，因此不太理想。</li>
<li>通过触发父元素的 bfc 来改变父级元素的渲染规则，但在实际使用中，都会造成不同的麻烦，所以只能在实际开发过程中，根据需要来选择。</li>
<li>通过将首个块级子元素改变其显示模式，来规避 margin 塌陷。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[定位]]></title>
        <id>https://superpony.github.io//post/xiang-dui-ding-wei</id>
        <link href="https://superpony.github.io//post/xiang-dui-ding-wei">
        </link>
        <updated>2019-11-02T13:16:31.000Z</updated>
        <content type="html"><![CDATA[<h2 id="定义的三种机制">定义的三种机制</h2>
<ul>
<li>
<p>普通流 static： 元素的默认属性，没有定位，遵循文档流。</p>
</li>
<li>
<p>绝对定位 absolute：被绝对定位的元素，会彻底脱离文档流，其原本在流中占据的位置被移除。</p>
</li>
<li>
<p>相对定位：相对定位的元素以原本所在的位置进行偏移，其原本在流中的位置被保留。</p>
</li>
</ul>
<hr>
<h2 id="绝对定位">绝对定位</h2>
<h3 id="absolute">absolute</h3>
<ul>
<li>如果父元素也是使用定位的元素，则在定位时，以父元素作为参照物，否则以根元素作为参照物。</li>
<li>当以根元素作为参照物时，bottom 定位时，则是以<strong>视口</strong>的左下角进行定位，但与 fiexd 不同的是，absolute 定位的元素不会随着屏幕的滚动而移动。</li>
</ul>
<h3 id="fiexd">fiexd</h3>
<ul>
<li>fiexd 以参照物为<strong>视口</strong>，当屏幕滚动时，fiexd 定位的元素随之移动。</li>
</ul>
<hr>
<h2 id="单位">单位</h2>
<ul>
<li>
<p>百分比： 当偏移的值以 % 作为单位时，其实际移动的偏移量为 父元素宽｜高 * 百分比。</p>
</li>
<li>
<p>例如：</p>
</li>
</ul>
<pre><code>    &lt;style&gt;
        #app {
            height: 500px;
            width: 500px;
            background-color: blue;
        }

        #demo {
            height: 100px;
            width: 100px;
            background-color: green;
            position: relative;
            left: 10%; // 实际向右偏移50px。
        }
    &lt;style&gt;

    &lt;div id=&quot;app&quot;&gt;
        &lt;div id=&quot;demo&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;

</code></pre>
]]></content>
    </entry>
</feed>